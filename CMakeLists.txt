cmake_minimum_required(VERSION 2.8)

# project info
project(cell_algorithms)
enable_language(CXX)

# save incoming CXX flags for forwarding to modcc external project
set(SAVED_CXX_FLAGS "${CMAKE_CXX_FLAGS}")

# compilation flags
set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
include("CompilerOptions")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXXOPT_DEBUG} ${CXXOPT_CXX11} ${CXXOPT_PTHREAD} ${CXXOPT_WALL}")

# this generates a .json file with full compilation command for each file
set(CMAKE_EXPORT_COMPILE_COMMANDS "YES")

# generated .a and .so go into /lib
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

#----------------------------------------------------------
# Option to enable assertions
#----------------------------------------------------------
option(NMC_WITH_ASSERTIONS "enable EXPECTS() assertions in code" OFF)
if(NMC_WITH_ASSERTIONS)
    add_definitions("-DNMC_HAVE_ASSERTIONS")
endif()

#----------------------------------------------------------
# Option to enable traces
#----------------------------------------------------------
option(NMC_WITH_TRACE "enable TRACE() macros in code" OFF)
if(NMC_WITH_TRACE)
    add_definitions("-DNMC_HAVE_TRACE")
endif()

#----------------------------------------------------------
# Option to disable auto running of modcc compiler
#----------------------------------------------------------
option(NMC_AUTO_RUN_MODCC_ON_CHANGES
  "Rerun modcc compiler whenever *.mod file or modcc compiler change" ON)

#----------------------------------------------------------
# prepare list of libraries/includes needed by external libs
#----------------------------------------------------------
set(EXTERNAL_LIBRARIES "")
set(EXTERNAL_INCLUDES "")

#----------------------------------------------------------
# Threading model selection
#----------------------------------------------------------
set(NMC_THREADING_MODEL "serial" CACHE STRING "set the threading model, one of serial/tbb/omp/cthread")
set_property(CACHE NMC_THREADING_MODEL PROPERTY STRINGS serial tbb omp cthread)

if(NMC_THREADING_MODEL MATCHES "tbb")
    # TBB support
    find_package(TBB REQUIRED)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${TBB_DEFINITIONS}")
    add_definitions(-DNMC_HAVE_TBB)
    set(NMC_WITH_TBB TRUE)
    list(APPEND EXTERNAL_LIBRARIES ${TBB_LIBRARIES})
    list(APPEND EXTERNAL_INCLUDES ${TBB_INCLUDE_DIRS})

elseif(NMC_THREADING_MODEL MATCHES "omp")
    # OpenMP support
    find_package(OpenMP REQUIRED)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    add_definitions(-DNMC_HAVE_OMP)
    set(NMC_WITH_OMP TRUE)

elseif(NMC_THREADING_MODEL MATCHES "cthread")
    find_package(Threads REQUIRED)
    add_definitions(-DNMC_HAVE_CTHREAD)
    set(NMC_WITH_CTHREAD TRUE)
    list(APPEND EXTERNAL_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})

    if(CMAKE_USE_PTHREADS_INIT)
      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")
    endif()

elseif(NMC_THREADING_MODEL MATCHES "serial")
    #setup previously done

else()
    message( FATAL_ERROR "-- Threading model '${NMC_THREADING_MODEL}' not supported, use one of serial/tbb/omp")

endif()

#----------------------------------------------------------
# libunwind for pretty printing stack traces
#----------------------------------------------------------
find_package(Unwind)
if(UNWIND_FOUND)
    add_definitions(-DWITH_UNWIND)
    include_directories(${UNWIND_INCLUDE_DIR})
    list(APPEND EXTERNAL_LIBRARIES ${UNWIND_LIBRARIES})
endif()

#----------------------------------------------------------
# CUDA support
#----------------------------------------------------------
option(NMC_WITH_CUDA "use CUDA for GPU offload" OFF)
if(NMC_WITH_CUDA)
    find_package(CUDA REQUIRED)

    # Turn off annoying and incorrect warnings generated in the JSON file.
    # We also work around the same issue with the intel compiler.
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-Xcudafe \"--diag_suppress=not_used_in_template_function_params\";-Xcudafe \"--diag_suppress=cast_to_qualified_type\")

    # set the CUDA target specfic flags
    # code regions protected by NMC_HAVE_CUDA should only be available to the CUDA
    # compiler, which regions protected by NMC_HAVE_GPU are visible to both host
    # and device compiler when targetting GPU.
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-DNMC_HAVE_CUDA)
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-DNMC_HAVE_GPU)
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-arch=sm_35)
    #set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-arch=sm_60)

    add_definitions(-DNMC_HAVE_GPU)
    include_directories(SYSTEM ${CUDA_INCLUDE_DIRS})
    list(APPEND EXTERNAL_LIBRARIES ${CUDA_LIBRARIES})
endif()

#----------------------------------------------------------
# Cray/BGQ/Generic Linux/other flag?
#----------------------------------------------------------
set(NMC_SYSTEM_TYPE "Generic" CACHE STRING 
    "Choose a system type to customize flags")
set_property(CACHE NMC_SYSTEM_TYPE PROPERTY STRINGS Generic Cray BGQ )

# Cray specific flags
if(${NMC_SYSTEM_TYPE} MATCHES "Cray")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -dynamic")
endif()

#----------------------------------------------------------
# MPI support
#----------------------------------------------------------
set(NMC_DISTRIBUTED_MODEL "serial" CACHE STRING "set the global communication model, one of serial/mpi/dryrun")
set_property(CACHE NMC_DISTRIBUTED_MODEL PROPERTY STRINGS serial mpi dryrun)

if(NMC_DISTRIBUTED_MODEL MATCHES "mpi")
   # BGQ specific flags
   if(${NMC_SYSTEM_TYPE} MATCHES "BGQ" )
      # On BGQ, set CXX to the mpi wrapper, and pass it a static
      add_definitions(-DMPICH2_CONST=const)
      set(MPI_FOUND TRUE)
    endif()

    if (NOT MPI_FOUND)
      find_package(MPI REQUIRED)
    endif()
    include_directories(SYSTEM ${MPI_C_INCLUDE_PATH})
    add_definitions(-DNMC_HAVE_MPI)

    # unfortunate workaround for C++ detection in system mpi.h
    add_definitions(-DMPICH_SKIP_MPICXX=1 -DOMPI_SKIP_MPICXX=1)
    set_property(DIRECTORY APPEND_STRING PROPERTY COMPILE_OPTIONS "${MPI_C_COMPILE_FLAGS}")

    set(NMC_WITH_MPI TRUE)

elseif(NMC_DISTRIBUTED_MODEL MATCHES "dryrun")
    add_definitions(-DNMC_HAVE_DRYRUN)
    set(NMC_WITH_DRYRUN TRUE)

elseif(NMC_DISTRIBUTED_MODEL MATCHES "serial")
    # no additional set up needed

else()
    message( FATAL_ERROR "-- Distributed communication model '${NMC_DISTRIBUTED_MODEL}' not supported, use one of serial/mpi/dryrun")
endif()

#----------------------------------------------------------
# Internal profiler support
#----------------------------------------------------------
option(NMC_WITH_PROFILING "use built-in profiling of miniapp" OFF)
if(NMC_WITH_PROFILING)
    add_definitions(-DNMC_HAVE_PROFILING)
endif()

#----------------------------------------------------------
# vectorization target
#----------------------------------------------------------
set(NMC_VECTORIZE_TARGET "none" CACHE STRING "CPU target for vectorization {KNL,AVX,AVX2}")
set_property(CACHE NMC_VECTORIZE_TARGET PROPERTY STRINGS none KNL AVX AVX2)

if(NMC_VECTORIZE_TARGET STREQUAL "KNL")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXXOPT_KNL}")
elseif(NMC_VECTORIZE_TARGET STREQUAL "AVX")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXXOPT_AVX}")
elseif(NMC_VECTORIZE_TARGET STREQUAL "AVX2")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXXOPT_AVX2}")
endif()

#----------------------------------------------------------
# whether to generate optimized kernels from NMODL
#----------------------------------------------------------
option(NMC_USE_OPTIMIZED_KERNELS
  "generate optimized code that vectorizes with the Intel compiler" OFF)

#----------------------------------------------------------
# Which communicator algorithm to use for finding
#  spike:connection matches: linear/global/domain
#  linear is O(nodes),
#  global is O(log(nodes)),
#  domain is O(log(neurons/nodes))
#----------------------------------------------------------
set(NMC_USE_QUEUE "domain" CACHE STRING
  "set the communication connection algorithm, one of linear/global/domain")
set_property(CACHE NMC_USE_QUEUE PROPERTY STRINGS linear global domain)

if(NMC_USE_QUEUE MATCHES "linear")
  add_definitions(-DNMC_USE_LINEAR_QUEUE)
elseif(NMC_USE_QUEUE MATCHES "global")
  add_definitions(-DNMC_USE_GLOBAL_SEARCH_QUEUE)
elseif(NMC_USE_QUEUE MATCHES "domain")
  add_definitions(-DNMC_USE_DOMAIN_SEARCH_QUEUE)
else()
    message(FATAL_ERROR "-- Communication connectoin algorithm '${NMC_USE_QUEUE}' not supported, use one of linear/global/domain")
endif()

#----------------------------------------------------------
# Only build modcc if it has not already been installed.
# This is useful if cross compiling for KNL, when it is not desirable to compile
# modcc with the same flags that are used for the KNL target.
#----------------------------------------------------------
set(use_external_modcc OFF)
find_program(MODCC_BIN modcc)
if(MODCC_BIN)
    set(use_external_modcc ON)
    set(modcc "${MODCC_BIN}")
else()
    set(modcc $<TARGET_FILE:modcc>)
endif()

#----------------------------------------------------------
# Validation data generation
#----------------------------------------------------------
# destination directory for generated data
set(NMC_VALIDATION_DATA_DIR "${PROJECT_SOURCE_DIR}/validation/data" CACHE PATH
  "location of generated validation data")

#----------------------------------------------------------
# Whether to build validation data at all
#----------------------------------------------------------
option(NMC_BUILD_VALIDATION_DATA "generate validation data" ON)

# Whether to attempt to use julia to build validation data
find_program(JULIA_BIN julia)
if(JULIA_BIN STREQUAL "JULIA_BIN-NOTFOUND")
    message(STATUS "julia not found; will not automatically build validation data sets from julia scripts")
    set(NMC_BUILD_JULIA_VALIDATION_DATA FALSE)
else()
    set(NMC_BUILD_JULIA_VALIDATION_DATA TRUE)
endif()

# Whether to attempt to use nrniv to build validation data
# (if we find nrniv, do)
find_program(NRNIV_BIN nrniv)
if(NRNIV_BIN STREQUAL "NRNIV_BIN-NOTFOUND")
    message(STATUS "nrniv not found; will not automatically build NEURON validation data sets")
    set(NMC_BUILD_NRN_VALIDATION_DATA FALSE)
else()
    set(NMC_BUILD_NRN_VALIDATION_DATA TRUE)
endif()

#----------------------------------------------------------
# Setup include dirs
#----------------------------------------------------------
include_directories(
    "${PROJECT_SOURCE_DIR}/tclap"
    "${PROJECT_SOURCE_DIR}/include"
    "${PROJECT_SOURCE_DIR}/src"
    "${PROJECT_SOURCE_DIR}/miniapp"
    "${PROJECT_SOURCE_DIR}/modcc"
    "${PROJECT_SOURCE_DIR}")
if(EXTERNAL_INCLUDES)
  include_directories("${EXTERNAL_INCLUDES}")
endif()

#----------------------------------------------------------
# Setup subdirs
#----------------------------------------------------------
# only include validation data if flag is set
if(NMC_BUILD_VALIDATION_DATA)
    add_subdirectory(validation)
endif()

# only compile modcc if it is not provided externally
if(NOT use_external_modcc)
    add_subdirectory(modcc)
endif()

add_subdirectory(mechanisms)
add_subdirectory(src)
add_subdirectory(tests)
add_subdirectory(miniapp)

